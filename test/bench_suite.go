package test

import (
	"flag"
	"fmt"
	"os"
	"reflect"
	"regexp"
	"testing"
)

var allBenchmarksFilter = func(_, _ string) (bool, error) { return true, nil }
var matchBenchMethod = flag.String("testify.b", "", "regular expression to select benchmarks of the testify suite to run")

// Suite is a basic testing suite with methods for storing and
// retrieving the current *testing.B context.
type Suite struct {
	b *testing.B
}

// B retrieves the current *testing.B context.
func (suite *Suite) B() *testing.B {
	return suite.b
}

// SetB sets the current *testing.B context.
func (suite *Suite) SetB(b *testing.B) {
	suite.b = b
}

// Run takes a testing suite and runs all of the benchmarks attached
// to it.
func Run(b *testing.B, suite BenchingSuite) {
	suite.SetB(b)

	if setupAllSuite, ok := suite.(SetupAllSuite); ok {
		setupAllSuite.SetupSuite()
	}
	defer func() {
		if tearDownAllSuite, ok := suite.(TearDownAllSuite); ok {
			tearDownAllSuite.TearDownSuite()
		}
	}()

	methodFinder := reflect.TypeOf(suite)
	benchmarks := []testing.InternalBenchmark{}
	for index := 0; index < methodFinder.NumMethod(); index++ {
		method := methodFinder.Method(index)
		ok, err := methodFilter(method.Name)
		if err != nil {
			fmt.Fprintf(os.Stderr, "testify: invalid regexp for -m: %s\n", err)
			os.Exit(1)
		}
		if ok {
			benchmark := testing.InternalBenchmark{
				Name: method.Name,
				F: func(b *testing.B) {
					parentB := suite.B()
					suite.SetB(b)
					if setupBenchmarkSuite, ok := suite.(SetupBenchmarkSuite); ok {
						setupBenchmarkSuite.SetupBenchmark()
					}
					if beforeBenchmarkSuite, ok := suite.(BeforeBenchmark); ok {
						beforeBenchmarkSuite.BeforeBenchmark(methodFinder.Elem().Name(), method.Name)
					}
					defer func() {
						if afterBenchmarkSuite, ok := suite.(AfterBenchmark); ok {
							afterBenchmarkSuite.AfterBenchmark(methodFinder.Elem().Name(), method.Name)
						}
						if tearDownBenchmarkSuite, ok := suite.(TearDownBenchmarkSuite); ok {
							tearDownBenchmarkSuite.TearDownBenchmark()
						}
						suite.SetB(parentB)
					}()
					method.Func.Call([]reflect.Value{reflect.ValueOf(suite)})
				},
			}
			benchmarks = append(benchmarks, benchmark)
		}
	}
	runBenchmarks(b, benchmarks)
}

func runBenchmarks(b testing.TB, benchmarks []testing.InternalBenchmark) {
	r, ok := b.(runner)
	if !ok {
		testing.RunBenchmarks(allBenchmarksFilter, benchmarks)
		return
	}

	for _, bench := range benchmarks {
		r.Run(bench.Name, bench.F)
	}
}

// Filtering method according to set regular expression
// specified command-line argument -m
func methodFilter(name string) (bool, error) {
	if ok, _ := regexp.MatchString("^Benchmark", name); !ok {
		return false, nil
	}
	return regexp.MatchString(*matchBenchMethod, name)
}

type runner interface {
	Run(name string, f func(b *testing.B)) bool
}

// BenchingSuite can store and return the current *testing.B context
// generated by 'go test -bench=.'.
type BenchingSuite interface {
	B() *testing.B
	SetB(*testing.B)
}

// SetupAllSuite has a SetupSuite method, which will run before the
// benchmarks in the suite are run.
type SetupAllSuite interface {
	SetupSuite()
}

// SetupBenchmarkSuite has a SetupBenchmark method, which will run before each
// benchmark in the suite.
type SetupBenchmarkSuite interface {
	SetupBenchmark()
}

// TearDownAllSuite has a TearDownSuite method, which will run after
// all the benchmarks in the suite have been run.
type TearDownAllSuite interface {
	TearDownSuite()
}

// TearDownBenchmarkSuite has a TearDownBenchmark method, which will run after
// each benchmark in the suite.
type TearDownBenchmarkSuite interface {
	TearDownBenchmark()
}

// BeforeBenchmark has a function to be executed right before the benchmark
// starts and receives the suite and benchmark names as input
type BeforeBenchmark interface {
	BeforeBenchmark(suiteName, testName string)
}

// AfterBenchmark has a function to be executed right after the benchmark
// finishes and receives the suite and benchmark names as input
type AfterBenchmark interface {
	AfterBenchmark(suiteName, testName string)
}
